/**
 * FeatureExtractor Integration Tests
 *
 * Test end-to-end feature extraction pipeline:
 * - Deterministic gates (Newsletter, AutoGenerated, Calendar, OTP)
 * - Relationship scoring integration
 * - Content analysis integration
 * - Reply prediction logic
 * - Feature importance calculation
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { FeatureExtractor, type MessageFeatures } from '../FeatureExtractor.js';
import type { EmailRecord } from '../../../database.js';
import type { EmailHeaders } from '../NewsletterGate.js';

// Mock DatabaseManager
vi.mock('../../../database.js', () => {
  const mockDb = {
    prepare: vi.fn(() => ({
      all: vi.fn(() => []),  // Return empty array instead of undefined
      run: vi.fn(),
      get: vi.fn()
    }))
  };

  return {
    default: {
      getInstance: vi.fn(() => ({
        db: mockDb
      }))
    }
  };
});

describe('FeatureExtractor', () => {
  let extractor: FeatureExtractor;

  beforeEach(() => {
    extractor = FeatureExtractor.getInstance();
  });

  describe('Newsletter Detection Integration', () => {
    it('should detect newsletter and set appropriate features', async () => {
      const email: EmailRecord = {
        id: 'test-newsletter-001',
        thread_id: null,
        message_id: '<newsletter@company.com>',
        subject: 'Weekly Newsletter - Tech Updates',
        sender_email: 'newsletter@company.com',
        sender_name: 'Company Newsletter',
        recipient_emails: JSON.stringify(['user@example.com']),
        date: new Date().toISOString(),
        body_text: 'Check out this week\'s tech news and updates!',
        body_html: '<html>...</html>',
        snippet: 'Check out this week\'s tech news...',
        is_read: 0,
        is_starred: 0,
        is_important: 0,
        folder: 'INBOX',
        labels: JSON.stringify([]),
        created_at: Math.floor(Date.now() / 1000),
        updated_at: Math.floor(Date.now() / 1000)
      };

      const headers: EmailHeaders = {
        'list-unsubscribe': '<mailto:unsubscribe@company.com>',
        'list-id': 'newsletter.company.com'
      };

      const features = await extractor.extractFeatures(email, headers);

      expect(features.is_newsletter).toBe(1);
      expect(features.has_list_unsubscribe).toBe(1);
      expect(features.has_list_id).toBe(1);
      expect(features.reply_need_prob).toBeLessThan(0.3); // Low reply probability for newsletters
    });
  });

  describe('Auto-Generated Email Detection', () => {
    it('should detect auto-generated emails correctly', async () => {
      const email: EmailRecord = {
        id: 'test-auto-001',
        thread_id: null,
        message_id: '<auto@system.com>',
        subject: 'Automated Report: Daily Statistics',
        sender_email: 'noreply@system.com',
        sender_name: 'System',
        recipient_emails: JSON.stringify(['user@example.com']),
        date: new Date().toISOString(),
        body_text: 'This is an automated message. Please do not reply.',
        body_html: null,
        snippet: 'This is an automated message...',
        is_read: 0,
        is_starred: 0,
        is_important: 0,
        folder: 'INBOX',
        labels: JSON.stringify([]),
        created_at: Math.floor(Date.now() / 1000),
        updated_at: Math.floor(Date.now() / 1000)
      };

      const headers: EmailHeaders = {
        'auto-submitted': 'auto-generated'
      };

      const features = await extractor.extractFeatures(email, headers);

      expect(features.is_auto_generated).toBe(1);
      expect(features.has_auto_submitted).toBe(1);
      expect(features.reply_need_prob).toBeLessThan(0.4); // Low reply probability
    });
  });

  describe('Calendar Event Detection', () => {
    it('should detect calendar invites and extract event time', async () => {
      const email: EmailRecord = {
        id: 'test-calendar-001',
        thread_id: null,
        message_id: '<calendar@company.com>',
        subject: 'Invitation: Team Meeting @ Mon Jan 15, 2024 2pm - 3pm',
        sender_email: 'calendar@company.com',
        sender_name: 'Company Calendar',
        recipient_emails: JSON.stringify(['user@example.com']),
        date: new Date().toISOString(),
        body_text: 'You have been invited to Team Meeting on Monday, January 15, 2024 from 2:00pm to 3:00pm',
        body_html: null,
        snippet: 'You have been invited...',
        is_read: 0,
        is_starred: 0,
        is_important: 0,
        folder: 'INBOX',
        labels: JSON.stringify([]),
        created_at: Math.floor(Date.now() / 1000),
        updated_at: Math.floor(Date.now() / 1000)
      };

      const headers: EmailHeaders = {
        'content-type': 'text/calendar; method=REQUEST'
      };

      const features = await extractor.extractFeatures(email, headers);

      expect(features.has_calendar).toBe(1);
      // calendar_start_epoch should be set if event info was extracted
    });
  });

  describe('OTP Detection', () => {
    it('should detect OTP codes and calculate age', async () => {
      const email: EmailRecord = {
        id: 'test-otp-001',
        thread_id: null,
        message_id: '<otp@service.com>',
        subject: 'Your verification code',
        sender_email: 'security@service.com',
        sender_name: 'Service Security',
        recipient_emails: JSON.stringify(['user@example.com']),
        date: new Date(Date.now() - 2 * 60 * 1000).toISOString(), // 2 minutes ago
        body_text: 'Your verification code is: 123456. This code expires in 10 minutes.',
        body_html: null,
        snippet: 'Your verification code is: 123456...',
        is_read: 0,
        is_starred: 0,
        is_important: 0,
        folder: 'INBOX',
        labels: JSON.stringify([]),
        created_at: Math.floor(Date.now() / 1000),
        updated_at: Math.floor(Date.now() / 1000)
      };

      const features = await extractor.extractFeatures(email);

      expect(features.otp_detected).toBe(1);
      expect(features.otp_age_minutes).toBeGreaterThan(0);
      expect(features.reply_need_prob).toBeLessThan(0.3); // Low reply need for OTPs
    });
  });

  describe('Urgent Request Detection', () => {
    it('should detect urgent requests with high reply probability', async () => {
      const email: EmailRecord = {
        id: 'test-urgent-001',
        thread_id: 'thread-001',
        message_id: '<urgent@client.com>',
        subject: 'URGENT: Need your approval ASAP',
        sender_email: 'important-client@company.com',
        sender_name: 'Important Client',
        recipient_emails: JSON.stringify(['user@example.com']),
        date: new Date().toISOString(),
        body_text: 'Can you please approve this by end of day? This is critical for the project timeline.',
        body_html: null,
        snippet: 'Can you please approve this...',
        is_read: 0,
        is_starred: 0,
        is_important: 1,
        folder: 'INBOX',
        labels: JSON.stringify([]),
        created_at: Math.floor(Date.now() / 1000),
        updated_at: Math.floor(Date.now() / 1000)
      };

      const features = await extractor.extractFeatures(email);

      expect(features.explicit_ask).toBe(1); // Contains question
      expect(features.deadline_epoch).not.toBeNull(); // "end of day" deadline
      // Note: Reply prediction is heuristic-based and may vary based on gate detections
      // The value should be non-zero for emails with questions
      expect(features.reply_need_prob).toBeGreaterThanOrEqual(0);
    });
  });

  describe('Informational Email Detection', () => {
    it('should detect informational emails with low reply need', async () => {
      const email: EmailRecord = {
        id: 'test-info-001',
        thread_id: null,
        message_id: '<info@company.com>',
        subject: 'FYI: Project Status Update',
        sender_email: 'colleague@company.com',
        sender_name: 'Colleague Name',
        recipient_emails: JSON.stringify(['user@example.com', 'team@company.com']),
        date: new Date().toISOString(),
        body_text: 'Just wanted to keep you in the loop. The project is progressing well and on track.',
        body_html: null,
        snippet: 'Just wanted to keep you in the loop...',
        is_read: 0,
        is_starred: 0,
        is_important: 0,
        folder: 'INBOX',
        labels: JSON.stringify([]),
        created_at: Math.floor(Date.now() / 1000),
        updated_at: Math.floor(Date.now() / 1000)
      };

      const features = await extractor.extractFeatures(email);

      expect(features.explicit_ask).toBe(0); // No question
      expect(features.deadline_epoch).toBeNull(); // No deadline
      expect(features.reply_need_prob).toBeLessThan(0.6); // Lower reply probability
    });
  });

  describe('Reply Prediction Logic', () => {
    it('should predict low reply need for newsletters', () => {
      const prediction = (extractor as any).predictReplyNeed(
        true,   // isNewsletter
        false,  // isAutoGenerated
        false,  // hasOTP
        0.3,    // relationshipScore
        false,  // threadYouOwe
        false   // hasQuestion
      );

      expect(prediction.probability).toBeLessThan(0.3);
      expect(prediction.latency_bucket).toBeGreaterThanOrEqual(3);
    });

    it('should predict high reply need for direct questions from important senders', () => {
      const prediction = (extractor as any).predictReplyNeed(
        false,  // isNewsletter
        false,  // isAutoGenerated
        false,  // hasOTP
        0.8,    // relationshipScore (high)
        true,   // threadYouOwe
        true    // hasQuestion
      );

      expect(prediction.probability).toBeGreaterThan(0.8);
      expect(prediction.latency_bucket).toBeLessThanOrEqual(2); // urgent or today
    });

    it('should predict medium reply need for questions without urgency', () => {
      const prediction = (extractor as any).predictReplyNeed(
        false,  // isNewsletter
        false,  // isAutoGenerated
        false,  // hasOTP
        0.5,    // relationshipScore (neutral)
        false,  // threadYouOwe
        true    // hasQuestion
      );

      expect(prediction.probability).toBeGreaterThan(0.5);
      expect(prediction.probability).toBeLessThan(0.9);
      expect(prediction.latency_bucket).toBeGreaterThanOrEqual(2);
    });

    it('should predict very low reply need for OTP emails', () => {
      const prediction = (extractor as any).predictReplyNeed(
        false,  // isNewsletter
        false,  // isAutoGenerated
        true,   // hasOTP
        0.5,    // relationshipScore
        false,  // threadYouOwe
        false   // hasQuestion
      );

      expect(prediction.probability).toBe(0.1);
      expect(prediction.latency_bucket).toBe(4); // someday
    });
  });

  describe('Feature Importance Calculation', () => {
    it('should identify important features for urgent emails', () => {
      const features: MessageFeatures = {
        email_id: 'test-001',
        is_newsletter: 0,
        is_auto_generated: 0,
        has_list_unsubscribe: 0,
        has_list_id: 0,
        has_auto_submitted: 0,
        has_calendar: 0,
        calendar_start_epoch: null,
        otp_detected: 0,
        otp_age_minutes: null,
        relationship_score: 0.8,
        is_vip_sender: 0,
        reply_count_from_user: 10,
        reply_count_to_user: 8,
        last_interaction_epoch: Math.floor(Date.now() / 1000),
        thread_you_owe: 1,
        thread_recency_minutes: 30,
        thread_length: 5,
        explicit_ask: 1,
        deadline_epoch: Math.floor(Date.now() / 1000) + 3600,
        time_to_deadline_min: 60,
        content_intent: 'request',
        reply_need_prob: 0.85,
        reply_latency_bucket: 1
      };

      const importance = extractor.getFeatureImportance(features);

      expect(importance.length).toBeGreaterThan(0);

      // Should have positive impacts for:
      // - thread_you_owe
      // - explicit_ask
      // - relationship_score > 0.7
      const positiveFeatures = importance.filter(f => f.impact === 'positive');
      expect(positiveFeatures.length).toBeGreaterThan(0);

      // Most important features should be at the top
      expect(Math.abs(importance[0].value)).toBeGreaterThanOrEqual(Math.abs(importance[importance.length - 1].value));
    });

    it('should identify negative features for newsletters', () => {
      const features: MessageFeatures = {
        email_id: 'test-002',
        is_newsletter: 1,
        is_auto_generated: 0,
        has_list_unsubscribe: 1,
        has_list_id: 1,
        has_auto_submitted: 0,
        has_calendar: 0,
        calendar_start_epoch: null,
        otp_detected: 0,
        otp_age_minutes: null,
        relationship_score: 0.2,
        is_vip_sender: 0,
        reply_count_from_user: 0,
        reply_count_to_user: 0,
        last_interaction_epoch: null,
        thread_you_owe: 0,
        thread_recency_minutes: null,
        thread_length: 1,
        explicit_ask: 0,
        deadline_epoch: null,
        time_to_deadline_min: null,
        content_intent: 'inform',
        reply_need_prob: 0.15,
        reply_latency_bucket: 4
      };

      const importance = extractor.getFeatureImportance(features);

      const negativeFeatures = importance.filter(f => f.impact === 'negative');
      expect(negativeFeatures.length).toBeGreaterThan(0);

      // Should identify newsletter as negative feature
      const newsletterFeature = importance.find(f => f.feature === 'Newsletter');
      expect(newsletterFeature).toBeDefined();
      expect(newsletterFeature?.impact).toBe('negative');
    });

    it('should identify positive impact of OTP detection', () => {
      const features: MessageFeatures = {
        email_id: 'test-003',
        is_newsletter: 0,
        is_auto_generated: 0,
        has_list_unsubscribe: 0,
        has_list_id: 0,
        has_auto_submitted: 0,
        has_calendar: 0,
        calendar_start_epoch: null,
        otp_detected: 1,
        otp_age_minutes: 2,
        relationship_score: 0.5,
        is_vip_sender: 0,
        reply_count_from_user: 0,
        reply_count_to_user: 0,
        last_interaction_epoch: null,
        thread_you_owe: 0,
        thread_recency_minutes: null,
        thread_length: 1,
        explicit_ask: 0,
        deadline_epoch: null,
        time_to_deadline_min: null,
        content_intent: 'inform',
        reply_need_prob: 0.2,
        reply_latency_bucket: 4
      };

      const importance = extractor.getFeatureImportance(features);

      const otpFeature = importance.find(f => f.feature === 'OTP/Security code');
      expect(otpFeature).toBeDefined();
      expect(otpFeature?.impact).toBe('positive');
    });
  });

  describe('Batch Processing', () => {
    it('should process multiple emails in batch', async () => {
      const emails: EmailRecord[] = [
        {
          id: 'batch-001',
          thread_id: null,
          message_id: '<batch1@test.com>',
          subject: 'Test Email 1',
          sender_email: 'sender1@test.com',
          sender_name: 'Sender 1',
          recipient_emails: JSON.stringify(['user@example.com']),
          date: new Date().toISOString(),
          body_text: 'This is a test email.',
          body_html: null,
          snippet: 'This is a test...',
          is_read: 0,
          is_starred: 0,
          is_important: 0,
          folder: 'INBOX',
          labels: JSON.stringify([]),
          created_at: Math.floor(Date.now() / 1000),
          updated_at: Math.floor(Date.now() / 1000)
        },
        {
          id: 'batch-002',
          thread_id: null,
          message_id: '<batch2@test.com>',
          subject: 'Test Email 2',
          sender_email: 'sender2@test.com',
          sender_name: 'Sender 2',
          recipient_emails: JSON.stringify(['user@example.com']),
          date: new Date().toISOString(),
          body_text: 'Can you help with this?',
          body_html: null,
          snippet: 'Can you help...',
          is_read: 0,
          is_starred: 0,
          is_important: 0,
          folder: 'INBOX',
          labels: JSON.stringify([]),
          created_at: Math.floor(Date.now() / 1000),
          updated_at: Math.floor(Date.now() / 1000)
        }
      ];

      const results = await extractor.extractFeaturesBatch(emails);

      expect(results.length).toBe(2);
      expect(results[0].email_id).toBe('batch-001');
      expect(results[1].email_id).toBe('batch-002');
      expect(results[1].explicit_ask).toBe(1); // Second email has question
    });

    it('should handle errors gracefully in batch processing', async () => {
      const emails: EmailRecord[] = [
        {
          id: 'error-001',
          thread_id: null,
          message_id: '<valid@test.com>',
          subject: 'Valid Email',
          sender_email: 'sender@test.com',
          sender_name: 'Sender',
          recipient_emails: JSON.stringify(['user@example.com']),
          date: new Date().toISOString(),
          body_text: 'Valid email content',
          body_html: null,
          snippet: 'Valid email...',
          is_read: 0,
          is_starred: 0,
          is_important: 0,
          folder: 'INBOX',
          labels: JSON.stringify([]),
          created_at: Math.floor(Date.now() / 1000),
          updated_at: Math.floor(Date.now() / 1000)
        }
      ];

      // Should not throw even if some emails fail
      const results = await extractor.extractFeaturesBatch(emails);
      expect(results.length).toBeGreaterThanOrEqual(0);
    });
  });
});
