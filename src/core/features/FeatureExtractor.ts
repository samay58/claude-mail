/**
 * FeatureExtractor - Orchestrates all feature extraction gates
 *
 * This is the main pipeline that:
 * 1. Runs all deterministic gates (Newsletter, AutoGenerated, Calendar, OTP)
 * 2. Extracts all features for message_features table
 * 3. Updates sender_relationships table
 * 4. Provides feature vector for ML scoring
 */

import Database from 'better-sqlite3';
import DatabaseManager, { EmailRecord } from '../../database.js';
import { NewsletterGate, EmailHeaders } from './NewsletterGate.js';
import { AutoGeneratedGate } from './AutoGeneratedGate.js';
import { CalendarGate } from './CalendarGate.js';
import { OTPGate } from './OTPGate.js';
import { RelationshipScorer } from './RelationshipScorer.js';
import { ContentAnalyzer } from './ContentAnalyzer.js';

export interface MessageFeatures {
  email_id: string;

  // Deterministic gates (RFC-compliant)
  is_newsletter: number;
  is_auto_generated: number;
  has_list_unsubscribe: number;
  has_list_id: number;
  has_auto_submitted: number;
  has_calendar: number;
  calendar_start_epoch: number | null;
  otp_detected: number;
  otp_age_minutes: number | null;

  // Relationship features
  relationship_score: number;
  is_vip_sender: number;
  reply_count_from_user: number;
  reply_count_to_user: number;
  last_interaction_epoch: number | null;

  // Thread context features
  thread_you_owe: number;
  thread_recency_minutes: number | null;
  thread_length: number;

  // Content intent features
  explicit_ask: number;
  deadline_epoch: number | null;
  time_to_deadline_min: number | null;
  content_intent: string | null;

  // Reply prediction
  reply_need_prob: number;
  reply_latency_bucket: number;
}

export interface SenderRelationship {
  sender_email: string;
  emails_received: number;
  emails_sent_to: number;
  user_replies_count: number;
  sender_replies_count: number;
  two_way_exchanges: number;
  first_contact_epoch: number | null;
  last_contact_epoch: number | null;
  avg_reply_latency_minutes: number | null;
  relationship_score: number;
  is_vip: number;
}

export class FeatureExtractor {
  private static instance: FeatureExtractor;
  private db: DatabaseManager;
  private relationshipScorer: RelationshipScorer;
  private contentAnalyzer: ContentAnalyzer;
  private stmt: {
    insertFeatures?: Database.Statement;
    updateFeatures?: Database.Statement;
    getFeatures?: Database.Statement;
    insertRelationship?: Database.Statement;
    updateRelationship?: Database.Statement;
    getRelationship?: Database.Statement;
    getThreadEmails?: Database.Statement;
    getUserEmail?: Database.Statement;
  } = {};

  private constructor() {
    this.db = DatabaseManager.getInstance();
    this.relationshipScorer = RelationshipScorer.getInstance();
    this.contentAnalyzer = ContentAnalyzer.getInstance();
    this.prepareStatements();
  }

  static getInstance(): FeatureExtractor {
    if (!FeatureExtractor.instance) {
      FeatureExtractor.instance = new FeatureExtractor();
    }
    return FeatureExtractor.instance;
  }

  private prepareStatements() {
    // Note: We'll need to get direct database access for these statements
    // For now, we'll use the DatabaseManager methods
  }

  /**
   * Main extraction method - processes an email and extracts all features
   */
  async extractFeatures(email: EmailRecord, headers?: EmailHeaders): Promise<MessageFeatures> {
    const now = new Date();
    const emailDate = new Date(email.date);

    // 1. Run deterministic gates
    const newsletterResult = NewsletterGate.detect(
      email.sender_email,
      headers,
      email.subject
    );

    const autoGenResult = AutoGeneratedGate.detect(
      email.sender_email,
      headers,
      email.subject,
      email.body_text
    );

    const calendarResult = CalendarGate.detect(
      email.sender_email,
      headers,
      email.subject,
      email.body_text,
      undefined, // attachments - would need to add to EmailRecord
      headers?.['content-type']
    );

    const otpResult = OTPGate.detect(
      email.sender_email,
      email.subject,
      email.body_text,
      emailDate
    );

    // 2. Get/update sender relationship
    const relationship = await this.updateSenderRelationship(email);

    // 3. Get thread context
    const threadContext = await this.analyzeThreadContext(email);

    // 4. Analyze content intent
    const contentAnalysis = this.analyzeContent(email.subject, email.body_text || '');

    // 5. Calculate reply prediction
    const replyPrediction = this.predictReplyNeed(
      newsletterResult.isNewsletter,
      autoGenResult.isAutoGenerated,
      otpResult.hasOTP,
      relationship.relationship_score,
      threadContext.you_owe,
      contentAnalysis.has_question
    );

    // 6. Build feature object
    const features: MessageFeatures = {
      email_id: email.id,

      // Deterministic gates
      is_newsletter: newsletterResult.isNewsletter ? 1 : 0,
      is_auto_generated: autoGenResult.isAutoGenerated ? 1 : 0,
      has_list_unsubscribe: headers?.['list-unsubscribe'] ? 1 : 0,
      has_list_id: headers?.['list-id'] ? 1 : 0,
      has_auto_submitted: headers?.['auto-submitted'] ? 1 : 0,
      has_calendar: calendarResult.hasCalendar ? 1 : 0,
      calendar_start_epoch: calendarResult.eventInfo?.startTime
        ? Math.floor(calendarResult.eventInfo.startTime.getTime() / 1000)
        : null,
      otp_detected: otpResult.hasOTP ? 1 : 0,
      otp_age_minutes: otpResult.ageMinutes || null,

      // Relationship features
      relationship_score: relationship.relationship_score,
      is_vip_sender: relationship.is_vip,
      reply_count_from_user: relationship.user_replies_count,
      reply_count_to_user: relationship.sender_replies_count,
      last_interaction_epoch: relationship.last_contact_epoch,

      // Thread context
      thread_you_owe: threadContext.you_owe ? 1 : 0,
      thread_recency_minutes: threadContext.recency_minutes,
      thread_length: threadContext.length,

      // Content intent
      explicit_ask: contentAnalysis.has_question ? 1 : 0,
      deadline_epoch: contentAnalysis.deadline_epoch,
      time_to_deadline_min: contentAnalysis.deadline_epoch
        ? Math.floor((contentAnalysis.deadline_epoch * 1000 - now.getTime()) / 60000)
        : null,
      content_intent: contentAnalysis.intent,

      // Reply prediction
      reply_need_prob: replyPrediction.probability,
      reply_latency_bucket: replyPrediction.latency_bucket
    };

    // 7. Store features in database
    await this.storeFeatures(features);

    return features;
  }

  /**
   * Update sender relationship based on email
   */
  private async updateSenderRelationship(email: EmailRecord, userEmail: string = 'user@example.com'): Promise<SenderRelationship> {
    // Calculate relationship score using RelationshipScorer
    const scoreResult = await this.relationshipScorer.calculateRelationshipScore(
      email.sender_email,
      userEmail
    );

    // Update the database
    await this.relationshipScorer.updateSenderRelationship(
      email.sender_email,
      userEmail
    );

    return {
      sender_email: scoreResult.sender_email,
      emails_received: scoreResult.stats.emails_received,
      emails_sent_to: scoreResult.stats.emails_sent_to,
      user_replies_count: scoreResult.stats.user_replies_count,
      sender_replies_count: scoreResult.stats.sender_replies_count,
      two_way_exchanges: scoreResult.stats.two_way_exchanges,
      first_contact_epoch: scoreResult.stats.first_contact_epoch,
      last_contact_epoch: scoreResult.stats.last_contact_epoch,
      avg_reply_latency_minutes: scoreResult.stats.avg_reply_latency_minutes,
      relationship_score: scoreResult.score,
      is_vip: scoreResult.is_vip
    };
  }

  /**
   * Analyze thread context
   */
  private async analyzeThreadContext(email: EmailRecord): Promise<{
    you_owe: boolean;
    recency_minutes: number | null;
    length: number;
  }> {
    // TODO: Query emails table for thread_id
    // Determine if user owes a reply based on last sender

    return {
      you_owe: false,  // Would check if last message in thread is from sender
      recency_minutes: null,
      length: 1
    };
  }

  /**
   * Analyze content for questions, deadlines, and intent
   */
  private analyzeContent(subject: string, bodyText: string): {
    has_question: boolean;
    deadline_epoch: number | null;
    time_to_deadline_min: number | null;
    intent: string | null;
    urgency_level: number;
    action_items: string[];
  } {
    // Use ContentAnalyzer for comprehensive analysis
    const analysis = this.contentAnalyzer.analyzeContent(subject, bodyText);

    return {
      has_question: analysis.has_question,
      deadline_epoch: analysis.deadline_epoch,
      time_to_deadline_min: analysis.time_to_deadline_min,
      intent: analysis.intent,
      urgency_level: analysis.urgency_level,
      action_items: analysis.action_items
    };
  }

  /**
   * Predict reply need and latency
   */
  private predictReplyNeed(
    isNewsletter: boolean,
    isAutoGenerated: boolean,
    hasOTP: boolean,
    relationshipScore: number,
    threadYouOwe: boolean,
    hasQuestion: boolean
  ): {
    probability: number;
    latency_bucket: number;
  } {
    // Simple heuristic model - will be replaced with ML
    let probability = 0.5; // Base probability
    let latencyBucket = 3; // Default: this_week

    // Negative signals (reduce reply probability)
    if (isNewsletter) probability -= 0.4;
    if (isAutoGenerated) probability -= 0.3;

    // Positive signals (increase reply probability)
    if (hasQuestion) probability += 0.3;
    if (threadYouOwe) probability += 0.25;
    if (relationshipScore > 0.7) probability += 0.2;

    // Special cases
    if (hasOTP) {
      probability = 0.1; // Low probability of reply
      latencyBucket = 4; // someday
    }

    // Clamp probability
    probability = Math.max(0, Math.min(1, probability));

    // Adjust latency based on probability
    if (probability > 0.8) {
      latencyBucket = 1; // urgent
    } else if (probability > 0.6) {
      latencyBucket = 2; // today
    }

    return { probability, latency_bucket: latencyBucket };
  }

  /**
   * Store features in database
   */
  private async storeFeatures(features: MessageFeatures): Promise<void> {
    // TODO: Implement actual database insert/update
    // This would use prepared statements to insert into message_features table
    console.log('Storing features for email:', features.email_id);
  }

  /**
   * Batch process multiple emails
   */
  async extractFeaturesBatch(emails: EmailRecord[]): Promise<MessageFeatures[]> {
    const features: MessageFeatures[] = [];

    for (const email of emails) {
      try {
        const emailFeatures = await this.extractFeatures(email);
        features.push(emailFeatures);
      } catch (error) {
        console.error(`Failed to extract features for email ${email.id}:`, error);
      }
    }

    return features;
  }

  /**
   * Calculate feature importance (for explainability)
   */
  getFeatureImportance(features: MessageFeatures): {
    feature: string;
    value: number;
    impact: 'positive' | 'negative' | 'neutral';
  }[] {
    const importance: any[] = [];

    // High impact negative features
    if (features.is_newsletter) {
      importance.push({
        feature: 'Newsletter',
        value: -0.4,
        impact: 'negative'
      });
    }

    if (features.is_auto_generated) {
      importance.push({
        feature: 'Auto-generated',
        value: -0.3,
        impact: 'negative'
      });
    }

    // High impact positive features
    if (features.thread_you_owe) {
      importance.push({
        feature: 'You owe reply',
        value: 0.35,
        impact: 'positive'
      });
    }

    if (features.explicit_ask) {
      importance.push({
        feature: 'Contains question',
        value: 0.3,
        impact: 'positive'
      });
    }

    if (features.relationship_score > 0.7) {
      importance.push({
        feature: 'Important sender',
        value: 0.25,
        impact: 'positive'
      });
    }

    if (features.otp_detected) {
      importance.push({
        feature: 'OTP/Security code',
        value: 0.2,
        impact: 'positive'
      });
    }

    // Sort by absolute value
    importance.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));

    return importance;
  }
}