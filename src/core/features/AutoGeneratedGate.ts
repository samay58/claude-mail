/**
 * AutoGeneratedGate - RFC 3834 compliant auto-generated email detection
 *
 * Detects auto-generated emails using:
 * - Auto-Submitted header (RFC 3834)
 * - X-Auto-Response-Suppress header (Microsoft)
 * - Auto-reply patterns in subject
 * - Common auto-responder signatures
 */

import { EmailHeaders } from './NewsletterGate.js';

export interface AutoGeneratedDetectionResult {
  isAutoGenerated: boolean;
  confidence: number; // 0.0 to 1.0
  type?: 'vacation' | 'bounce' | 'receipt' | 'notification' | 'system' | 'unknown';
  reasons: string[];
}

export class AutoGeneratedGate {
  /**
   * RFC 3834 Auto-Submitted header values
   * - no: Message was not auto-generated
   * - auto-generated: Message was auto-generated
   * - auto-replied: Automatic reply (vacation, out-of-office)
   * - auto-notified: Automatic notification (delivery status)
   */
  private static readonly AUTO_SUBMITTED_VALUES = {
    'auto-generated': { confidence: 1.0, type: 'system' as const },
    'auto-replied': { confidence: 1.0, type: 'vacation' as const },
    'auto-notified': { confidence: 1.0, type: 'notification' as const }
  };

  /**
   * Microsoft X-Auto-Response-Suppress values
   * DR = Suppress delivery reports
   * RN = Suppress read notifications
   * NRN = Suppress non-read notifications
   * OOF = Suppress out-of-office responses
   * AutoReply = Suppress auto-reply messages
   */
  private static readonly MS_SUPPRESS_VALUES = ['DR', 'RN', 'NRN', 'OOF', 'AutoReply', 'All'];

  /**
   * Common auto-reply subject patterns
   */
  private static readonly AUTO_SUBJECT_PATTERNS = [
    // Out of office / vacation
    { pattern: /^(auto[- ]?reply|automatic reply)/i, type: 'vacation' as const },
    { pattern: /^(out of (the )?office|ooo)/i, type: 'vacation' as const },
    { pattern: /^(away|absence|vacation|holiday)/i, type: 'vacation' as const },
    { pattern: /automatische antwort/i, type: 'vacation' as const }, // German
    { pattern: /rÃ©ponse automatique/i, type: 'vacation' as const }, // French

    // Delivery notifications
    { pattern: /^(undeliverable|undelivered|delivery (status|failure|problem))/i, type: 'bounce' as const },
    { pattern: /^(mail delivery failed|returned mail)/i, type: 'bounce' as const },
    { pattern: /^(delivery status notification|dsn)/i, type: 'notification' as const },
    { pattern: /^(non[- ]delivery|ndr)/i, type: 'bounce' as const },

    // Read receipts
    { pattern: /^(read receipt|message read|read confirmation)/i, type: 'receipt' as const },
    { pattern: /^(delivered:|received:)/i, type: 'receipt' as const },

    // System notifications
    { pattern: /^(system (message|notification|alert))/i, type: 'system' as const },
    { pattern: /^(automated (message|response|notification))/i, type: 'system' as const },
    { pattern: /\[auto[- ]?generated\]/i, type: 'system' as const }
  ];

  /**
   * Common system/service email addresses
   */
  private static readonly SYSTEM_SENDERS = [
    /^(mailer-daemon|postmaster|abuse|root|admin|administrator)@/i,
    /^(system|automated|auto-reply|autoreply|do-not-reply)@/i,
    /^(bounce|bounces|bounced|undelivered)@/i,
    /daemon@/i,
    /^notify@/i,
    /^notification@/i,
    /^alert@/i
  ];

  /**
   * Body content patterns that indicate auto-generation
   */
  private static readonly AUTO_BODY_PATTERNS = [
    /this is an? (automatic|automated|auto-generated) (reply|response|message)/i,
    /i (am|will be) out of (the )?office/i,
    /i am currently away/i,
    /thank you for your (email|message).*?i will (get back|respond|reply)/i,
    /delivery to the following recipient(s)? failed/i,
    /the following message to .* was undeliverable/i,
    /your message .* could not be delivered/i,
    /this message was created automatically/i,
    /please do not (reply|respond) to this (email|message)/i,
    /this is a system[- ]generated (email|message)/i
  ];

  /**
   * Main detection method - combines all detection strategies
   */
  static detect(
    senderEmail: string,
    headers?: EmailHeaders,
    subject?: string,
    bodyText?: string
  ): AutoGeneratedDetectionResult {
    const reasons: string[] = [];
    let confidence = 0;
    let detectedType: AutoGeneratedDetectionResult['type'] = 'unknown';

    // 1. Check Auto-Submitted header (RFC 3834) - highest confidence
    if (headers?.['auto-submitted']) {
      const autoSubmitted = headers['auto-submitted'].toLowerCase();
      if (autoSubmitted !== 'no') {
        const config = this.AUTO_SUBMITTED_VALUES[autoSubmitted as keyof typeof AutoGeneratedGate.AUTO_SUBMITTED_VALUES];
        if (config) {
          confidence = config.confidence;
          detectedType = config.type;
          reasons.push(`Auto-Submitted header: ${autoSubmitted} (RFC 3834)`);
        }
      }
    }

    // 2. Check X-Auto-Response-Suppress (Microsoft)
    if (headers?.['x-auto-response-suppress']) {
      const suppress = headers['x-auto-response-suppress'];
      if (this.MS_SUPPRESS_VALUES.some(val => suppress.includes(val))) {
        confidence = Math.max(confidence, 0.95);
        reasons.push(`X-Auto-Response-Suppress header: ${suppress}`);
        if (suppress.includes('OOF')) {
          detectedType = 'vacation';
        }
      }
    }

    // 3. Check Return-Path header (empty or <> indicates bounce)
    if (headers?.['return-path'] === '<>' || headers?.['return-path'] === '') {
      confidence = Math.max(confidence, 0.90);
      detectedType = 'bounce';
      reasons.push('Empty Return-Path indicates bounce message');
    }

    // 4. Check Precedence header
    const precedence = headers?.['precedence']?.toLowerCase();
    if (precedence === 'auto_reply' || precedence === 'junk') {
      confidence = Math.max(confidence, 0.85);
      reasons.push(`Precedence header: ${precedence}`);
      if (precedence === 'auto_reply') {
        detectedType = detectedType === 'unknown' ? 'vacation' : detectedType;
      }
    }

    // 5. Check X-Autoreply header
    if (headers?.['x-autoreply'] === 'yes' || headers?.['x-autorespond']) {
      confidence = Math.max(confidence, 0.90);
      detectedType = detectedType === 'unknown' ? 'vacation' : detectedType;
      reasons.push('X-Autoreply/X-Autorespond header present');
    }

    // 6. Check subject patterns
    if (subject) {
      for (const { pattern, type } of this.AUTO_SUBJECT_PATTERNS) {
        if (pattern.test(subject)) {
          confidence = Math.max(confidence, 0.80);
          detectedType = detectedType === 'unknown' ? type : detectedType;
          reasons.push(`Subject matches auto-reply pattern: ${pattern.source}`);
          break;
        }
      }
    }

    // 7. Check sender patterns
    const senderLower = senderEmail.toLowerCase();
    for (const pattern of this.SYSTEM_SENDERS) {
      if (pattern.test(senderLower)) {
        confidence = Math.max(confidence, 0.75);
        detectedType = detectedType === 'unknown' ? 'system' : detectedType;
        reasons.push(`Sender matches system pattern: ${pattern.source}`);
        break;
      }
    }

    // 8. Check body content patterns (lower confidence)
    if (bodyText) {
      const bodySnippet = bodyText.substring(0, 500); // Check first 500 chars
      for (const pattern of this.AUTO_BODY_PATTERNS) {
        if (pattern.test(bodySnippet)) {
          confidence = Math.max(confidence, 0.65);
          reasons.push(`Body contains auto-generated pattern`);
          break;
        }
      }
    }

    // 9. Check for vacation-specific headers
    const vacationHeaders = [
      'x-vacation',
      'x-vacation-message',
      'x-autoresponder',
      'x-ms-exchange-inbox-rules-loop'
    ];

    for (const header of vacationHeaders) {
      if (headers?.[header]) {
        confidence = Math.max(confidence, 0.85);
        detectedType = 'vacation';
        reasons.push(`Has ${header.toUpperCase()} header`);
      }
    }

    // 10. Check for bounce-specific headers
    if (headers?.['x-failed-recipients'] || headers?.['x-original-recipient']) {
      confidence = Math.max(confidence, 0.90);
      detectedType = 'bounce';
      reasons.push('Has bounce-related headers');
    }

    return {
      isAutoGenerated: confidence >= 0.65, // 65% confidence threshold
      confidence,
      type: confidence >= 0.65 ? detectedType : undefined,
      reasons
    };
  }

  /**
   * Utility to check if an email is likely a bounce message
   */
  static isBounce(headers?: EmailHeaders, senderEmail?: string): boolean {
    // Check Return-Path
    if (headers?.['return-path'] === '<>' || headers?.['return-path'] === '') {
      return true;
    }

    // Check common bounce senders
    if (senderEmail) {
      const bouncePatterns = [
        /^mailer-daemon@/i,
        /^postmaster@/i,
        /^bounce[s]?@/i
      ];
      return bouncePatterns.some(p => p.test(senderEmail));
    }

    return false;
  }

  /**
   * Utility to check if an email is an out-of-office reply
   */
  static isOutOfOffice(headers?: EmailHeaders, subject?: string): boolean {
    // Check headers
    if (headers?.['auto-submitted'] === 'auto-replied') {
      return true;
    }

    if (headers?.['x-auto-response-suppress']?.includes('OOF')) {
      return true;
    }

    // Check subject
    if (subject) {
      const oofPatterns = [
        /out of (the )?office/i,
        /ooo/i,
        /vacation/i,
        /away/i,
        /auto[- ]?reply/i
      ];
      return oofPatterns.some(p => p.test(subject));
    }

    return false;
  }
}